#!/usr/bin/env python3
"""
Strategy Template
=================
Use this template to implement new trading strategies.

Copy this file and rename it to your_strategy_name.py
Then implement the required methods.
"""

import json
import logging
import sqlite3
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict

logger = logging.getLogger(__name__)


@dataclass
class StrategySignal:
    """Signal generated by strategy"""
    timestamp: str
    symbol: str
    side: str  # 'buy', 'sell', 'hold'
    confidence: float  # 0.0 to 1.0
    reason: str
    entry_price: Optional[float] = None
    exit_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict = None


@dataclass
class StrategyTrade:
    """Executed trade record"""
    trade_id: str
    timestamp: str
    symbol: str
    side: str
    amount: float
    price: float
    pnl: float
    status: str  # 'open', 'closed'
    metadata: Dict = None


class BaseStrategy:
    """
    Base class for all trading strategies.
    
    To create a new strategy:
    1. Inherit from this class
    2. Implement scan() method
    3. Implement generate_signal() method
    4. Add to trading_bot.py
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize strategy.
        
        Args:
            config: Strategy configuration dictionary
        """
        self.config = config
        self.name = config.get("name", "unnamed_strategy")
        self.enabled = config.get("enabled", True)
        
        # Risk parameters
        self.max_position_usd = config.get("max_position_usd", 100)
        self.stop_loss_pct = config.get("stop_loss_pct", 0.02)
        self.take_profit_pct = config.get("take_profit_pct", 0.04)
        
        # State
        self.signals: List[StrategySignal] = []
        self.trades: List[StrategyTrade] = []
        
        # Statistics
        self.stats = {
            "total_scans": 0,
            "signals_generated": 0,
            "trades_executed": 0,
            "wins": 0,
            "losses": 0,
            "total_pnl": 0.0
        }
        
        self._init_database()
        logger.info(f"[{self.name}] Strategy initialized")
    
    def _init_database(self):
        """Initialize database table for this strategy"""
        conn = sqlite3.connect("trades.db")
        table_name = f"strategy_{self.name.lower()}"
        conn.execute(f"""
            CREATE TABLE IF NOT EXISTS {table_name} (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                trade_id TEXT UNIQUE,
                timestamp TEXT,
                symbol TEXT,
                side TEXT,
                amount REAL,
                price REAL,
                pnl REAL,
                status TEXT,
                metadata TEXT
            )
        """)
        conn.commit()
        conn.close()
    
    def scan(self) -> List[StrategySignal]:
        """
        Scan for trading opportunities.
        
        This is the main method that should be implemented.
        
        Returns:
            List of trading signals
        """
        self.stats["total_scans"] += 1
        
        # TODO: Implement your scanning logic here
        # 1. Fetch market data
        # 2. Calculate indicators
        # 3. Check entry/exit conditions
        # 4. Generate signals
        
        raise NotImplementedError("Subclasses must implement scan()")
    
    def generate_signal(
        self,
        symbol: str,
        side: str,
        confidence: float,
        reason: str,
        **kwargs
    ) -> StrategySignal:
        """
        Generate a trading signal.
        
        Args:
            symbol: Trading pair (e.g., 'BTC/USDT')
            side: 'buy', 'sell', or 'hold'
            confidence: Signal confidence (0.0 to 1.0)
            reason: Human-readable reason for signal
            **kwargs: Additional parameters (entry_price, stop_loss, etc.)
            
        Returns:
            StrategySignal object
        """
        signal = StrategySignal(
            timestamp=datetime.now(timezone.utc).isoformat(),
            symbol=symbol,
            side=side,
            confidence=confidence,
            reason=reason,
            metadata=kwargs
        )
        
        self.signals.append(signal)
        self.stats["signals_generated"] += 1
        
        return signal
    
    def execute(self, signal: StrategySignal, mode: str = "PAPER") -> StrategyTrade:
        """
        Execute a trade based on signal.
        
        Args:
            signal: StrategySignal to execute
            mode: 'PAPER' or 'LIVE'
            
        Returns:
            StrategyTrade record
        """
        trade_id = f"{self.name.upper()}_{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S')}"
        
        # Calculate position size
        amount = self.max_position_usd / signal.entry_price if signal.entry_price else 0
        
        trade = StrategyTrade(
            trade_id=trade_id,
            timestamp=datetime.now(timezone.utc).isoformat(),
            symbol=signal.symbol,
            side=signal.side,
            amount=amount,
            price=signal.entry_price or 0,
            pnl=0.0,
            status="EXECUTED" if mode == "PAPER" else "PENDING",
            metadata=signal.metadata
        )
        
        self._save_trade(trade)
        self.trades.append(trade)
        self.stats["trades_executed"] += 1
        
        logger.info(f"[{self.name}] Executed {trade_id}: {signal.side} {signal.symbol}")
        
        return trade
    
    def _save_trade(self, trade: StrategyTrade):
        """Save trade to database"""
        try:
            conn = sqlite3.connect("trades.db")
            table_name = f"strategy_{self.name.lower()}"
            conn.execute(f"""
                INSERT OR REPLACE INTO {table_name}
                (trade_id, timestamp, symbol, side, amount, price, pnl, status, metadata)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                trade.trade_id, trade.timestamp, trade.symbol, trade.side,
                trade.amount, trade.price, trade.pnl, trade.status,
                json.dumps(trade.metadata) if trade.metadata else "{}"
            ))
            conn.commit()
            conn.close()
        except Exception as e:
            logger.error(f"[{self.name}] Error saving trade: {e}")
    
    def get_stats(self) -> Dict:
        """Get strategy statistics"""
        total = self.stats["wins"] + self.stats["losses"]
        return {
            **self.stats,
            "win_rate": (self.stats["wins"] / total * 100) if total > 0 else 0,
            "active_signals": len(self.signals),
            "open_trades": len([t for t in self.trades if t.status == "open"])
        }
    
    def run(self, mode: str = "PAPER", iterations: Optional[int] = None):
        """
        Run strategy continuously.
        
        Args:
            mode: 'PAPER' or 'LIVE'
            iterations: Number of scans (None for infinite)
        """
        logger.info(f"[{self.name}] Starting in {mode} mode...")
        
        iteration = 0
        while True:
            iteration += 1
            
            # Scan for opportunities
            signals = self.scan()
            
            # Execute signals
            for signal in signals:
                if signal.side != "hold" and signal.confidence > 0.7:
                    self.execute(signal, mode)
            
            # Check iteration limit
            if iterations and iteration >= iterations:
                break
            
            # Wait before next scan
            import time
            time.sleep(self.config.get("scan_interval_seconds", 60))
        
        logger.info(f"[{self.name}] Completed {iteration} iterations")
        return self.get_stats()


# Example implementation
class ExampleMomentumStrategy(BaseStrategy):
    """
    Example momentum strategy implementation.
    
    Buy when price is above SMA and rising.
    Sell when price falls below SMA.
    """
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.sma_period = config.get("sma_period", 20)
        self.symbols = config.get("symbols", ["BTC/USDT"])
    
    def scan(self) -> List[StrategySignal]:
        """Scan for momentum opportunities"""
        self.stats["total_scans"] += 1
        signals = []
        
        for symbol in self.symbols:
            try:
                # TODO: Fetch price data
                # current_price = fetch_price(symbol)
                # sma = calculate_sma(symbol, self.sma_period)
                
                # Example logic (replace with real data)
                current_price = 50000  # Placeholder
                sma = 49000  # Placeholder
                
                if current_price > sma * 1.02:  # 2% above SMA
                    signal = self.generate_signal(
                        symbol=symbol,
                        side="buy",
                        confidence=0.75,
                        reason=f"Price ${current_price} > SMA{self.sma_period} ${sma}",
                        entry_price=current_price,
                        stop_loss=current_price * 0.95,
                        take_profit=current_price * 1.05
                    )
                    signals.append(signal)
                    
                elif current_price < sma * 0.98:  # 2% below SMA
                    signal = self.generate_signal(
                        symbol=symbol,
                        side="sell",
                        confidence=0.70,
                        reason=f"Price ${current_price} < SMA{self.sma_period} ${sma}",
                        entry_price=current_price
                    )
                    signals.append(signal)
                    
            except Exception as e:
                logger.error(f"[{self.name}] Error scanning {symbol}: {e}")
        
        return signals


if __name__ == "__main__":
    # Example usage
    logging.basicConfig(level=logging.INFO)
    
    config = {
        "name": "example_momentum",
        "max_position_usd": 50,
        "sma_period": 20,
        "symbols": ["BTC/USDT", "ETH/USDT"],
        "scan_interval_seconds": 60
    }
    
    strategy = ExampleMomentumStrategy(config)
    
    # Single scan
    signals = strategy.scan()
    
    print(f"\nGenerated {len(signals)} signals:")
    for signal in signals:
        print(f"  {signal.side.upper()} {signal.symbol} @ {signal.entry_price}")
        print(f"    Confidence: {signal.confidence:.0%}")
        print(f"    Reason: {signal.reason}")
